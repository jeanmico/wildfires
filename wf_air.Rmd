---
title: "Wildfires"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Cmd+Shift+Enter*. 

```{r}
library(tmap)
library(ggplot2)
library(tidyr)
library(ggmap)
library(rgdal)
library(rgeos)
library(maptools)
library(dplyr)
library(tmap)
library(gstat)
library(raster)
library(sp)
library(sf)
```

Constants and globals
```{r}
fname_img <<- paste('/Users/student/wildfires/images/', Sys.Date(), '_', sep = '')
fname_csv <<- paste('/Users/student/wildfires/output/', Sys.Date(), '_', sep = '')
testdate <- as.Date('2018-11-15')
```

```{r}
file_naming <- function(f_name, f_type) {
  if (f_type == 'image') {
    return(paste(fname_img, f_name, '.png', sep=''))
  }
  else if (f_type == 'csv') {
    return(paste(fname_csv, f_name, '.csv', sep = ''))
  }
}

```

```{r}
idw_interpolate <- function(data_sp, interp_col, grid_n, weight_power) {
  # create empty grid
  grd <- as.data.frame(spsample(data_sp, 'regular', n=grid_n))
  names(grd) <- c("longitude", "latitude")
  coordinates(grd) <- c('longitude', 'latitude')
  gridded(grd) <- TRUE
  fullgrid(grd) <- TRUE
  
  # add projection to empty grid
  #proj4string(data_sp)
  crs(grd) <- proj4string(data_sp)
  
  # interpolate!
  data_sp_idw <- gstat::idw(data_sp[[interp_col]] ~ 1, data_sp, newdata=grd, idp=weight_power)
  
  #file_name = file_naming(fname, 'image')
  
  return(data_sp_idw)
}
```

```{r}
sensor_map <- function(sensor_df) {
  sensors_pa <- st_as_sf(sensor_df, coords =c("lon", "lat"), crs=4326)
  sens_plt <- tm_shape(sensors_pa) +
    tm_dots(col='gray')
  
  file_name = file_naming(fname, 'image')
  tmap_save()
  
  return(sens_plt)
}
```

```{r}
raster_map <- function(raster_sp, points_sp, bounding_box, legend_show, rast_title, fname) {
  r <- raster(raster_sp)
  
  # clip to California
  r_clip <- mask(r, ca_county_map)
  
  # map the interpolated raster
  rast_plt <- tm_shape(r_clip, bbox = bounding_box) +
    tm_raster(n=12, palette = "YlOrRd", title=rast_title, style='fixed', breaks=c(0,25,50,75,100,125,150,175,200,225,250,300,400)) +
    tm_shape(points_sp) + tm_dots(size=.2) +
    tm_legend(legend.outside=TRUE, legend.show=legend_show, legend.text.size=1.2)
  
  file_name = file_naming(fname, 'image')
  tmap_save(rast_plt + tm_layout(outer.margins = c(0,0,0,0)), file=file_name)
  
  return(rast_plt)
}
```

```{r}
line_plot <- function(df, xcol, ycol, line_title, x_label, y_label, fname) {
  Line_plt <- ggplot(df, aes(x=datesort, y=daily_mean_pm25, color = as.character(site_id), label=county)) +
    geom_line() +
    scale_color_brewer(palette="Accent") +
    xlab(x_label) +
    ylab(y_label) +
    labs(color = "Sensor", labels = plot_df$county) +
    scale_fill_discrete(breaks=plot_df$county)
  
  file_name = file_naming(fname, 'image')
  ggplot.save()
  
  return(line_plt)
}

```

Read in a map of the USA
```{r}
county_map = rgdal::readOGR('/Users/student/wildfires/cb_2018_us_county_5m')
```
Restrict the map to California
```{r}
ca_county_map <- subset(county_map, STATEFP == '06')
ca_county_map <<- spTransform(ca_county_map, CRS="+proj=longlat +datum=WGS84")
```


# PurpleAir data
```{r}
pa_pm25 = read.csv('~/wildfires/2018_purpleair.csv')

# remove NA (do a better job of trying to fix NA)
pa_pm25 <- pa_pm25 %>% filter(!is.na(pm25_atm_corr))

sensors_pa <- st_as_sf(pa_pm25, coords =c("lon", "lat"), crs=4326)

tm_shape(sensors_pa) +
  tm_dots(col='gray')
```

```{r}
coord_ref <- CRS("+proj=longlat +datum=WGS84")
purple_oneday <- pa_pm25 %>% filter(as.Date(day_date) == testdate)
pa_sp <- SpatialPointsDataFrame(coords = purple_oneday[ , c("lon", 'lat')], data = purple_oneday, proj4string=coord_ref)
```

Create an IDW interpolation of the PurpleAir data for Nov 15, 2018
```{r}
purple_idw <- idw_interpolate(pa_sp, 'pm25_atm_corr', 50000, 3)

purple_rast <- raster_map(purple_idw, pa_sp, pa_sp, TRUE, 'PurpleAir, corrected', 'purpleair_atm_corr_idw')

purple_rast
```

```{r}
purple_raw_idw <- idw_interpolate(pa_sp, 'mean_pm25_atm', 50000, 3)

purple_raw_rast <- raster_map(purple_raw_idw, pa_sp, pa_sp, TRUE, 'PurpleAir, raw', 'purpleair_atm_raw_idw')

purple_raw_rast
```

Plot the PurpleAir raw v PurpleAir corrected

```{r}
purple_corr_plt <- ggplot(pa_pm25, aes(x = mean_pm25_atm, y = pm25_atm_corr))+
  geom_point() +
  geom_abline(slope=1, intercept=0) +
  xlab('Raw PurpleAir PM2.5') +
  ylab('Corrected PurpleAir PM2.5') + 
  xlim(c(0,400)) + 
  ylim(c(0,400)) +
  coord_fixed()

purple_corr_plt

ggsave(purple_corr_plt, file=file_naming('PA_corrected_v_raw_atm', 'image'))
```


Read in the PM2.5 EPA data for 2018 (all of California)
```{r}
ca_pm25 = read.csv('~/wildfires/2018_CA_PM25_EPA.csv')
```

Rename columns for convenience
```{r}
colnames(ca_pm25) = c('date', 'source', 'site_id', 'poc', 'daily_mean_pm25', 'units', 'daily_aqi_value', 'site_name', 'daily_obs_count', 'percent_complete', 'aqs_parameter_code', 'aqs_parameter_desc', 'cbsa_code', 'cbsa_name', 'state_code', 'state', 'county_code', 'county', 'latitude', 'longitude')
```

Sort by date
```{r}
ca_pm25 <- ca_pm25 %>% mutate(datesort = as.Date(date, format='%m/%d/%Y'))
```


Explore the EPA data
```{r}
# filter out the counties we don't want
exclude_counties = read.csv('~/wildfires/exclude_county_sensors.csv')

ca_pm25 <- ca_pm25 %>% filter(!(county_code %in% exclude_counties$code))

epa_ids = unique(ca_pm25$site_id)
```
How many EPA sensors do we have?
```{r}
print(length(epa_ids))
```
Select 5 sensors randomly and plot their data for the year
```{r}
plot_ids = sample(epa_ids, size=5)
plot_df = ca_pm25 %>% filter(site_id %in% plot_ids)

# sort by date

ggplot(plot_df, aes(x=datesort, y=daily_mean_pm25, color = as.character(site_id), label=county)) +
  geom_line() +
  scale_color_brewer(palette="Accent") +
  xlab("Date") +
  ylab("Mean PM 2.5 concentration (\u03bcg/m\u00b3)") +
  labs(color = "Sensor", labels = plot_df$county) +
  scale_fill_discrete(breaks=plot_df$county)
  
```
# Geographic analysis

Get a dataframe of just the sensors with latitude and longitude
```{r}
sensors_epa = ca_pm25 %>% distinct(site_id, .keep_all=TRUE) %>% dplyr::select(site_id, site_name, cbsa_code, cbsa_name, state_code, state, county_code, county, latitude, longitude)
```

construct a 'shapefile' out of the csv
```{r}
sensors_sf <- st_as_sf(ca_pm25, coords =c("longitude", "latitude"), crs=4326)
```

Display the sensors on a map
```{r}
tm_shape(sensors_sf) +
  tm_dots(col='gray')
```

Testing out interpolation for a single day's readings
```{r}
day = as.Date('2018-11-15')
day_df <- ca_pm25 %>% filter(datesort == day)
#day_df <- day_df %>% filter(county_code %in% c(1, 13, 41, 75, 81, 85)) # restrict to sensors in the 6 bay area counties
coord_ref <- CRS("+proj=longlat +datum=WGS84")
day_sp <- SpatialPointsDataFrame(coords = day_df[ , c("longitude", 'latitude')], data = day_df, proj4string=coord_ref)
```

```{r}
epa_idw <- idw_interpolate(day_sp, 'daily_mean_pm25', 500000, 3)

epa_rast <- raster_map(epa_idw, day_sp, pa_sp, TRUE, 'PM2.5', 'epa_idw')

epa_rast
```
IDW
```{r}

# create empty grid
grd <- as.data.frame(spsample(day_sp, 'regular', n=500000))
names(grd) <- c("longitude", "latitude")
coordinates(grd) <- c('longitude', 'latitude')
gridded(grd) <- TRUE
fullgrid(grd) <- TRUE

# add projection to empty grid
proj4string(day_sp)
crs(grd) <- proj4string(day_sp)

# interpolate!
day_sp.idw <- gstat::idw(daily_mean_pm25 ~ 1, day_sp, newdata=grd, idp=4.0)

```



```{r}
r <- raster(day_sp.idw)

# clip to California
r_clip <- mask(r, ca_county_map)

# map the interpolated raster
epaplt_full <- tm_shape(r_clip) +
  tm_raster(n=10, palette = "YlOrRd", title="") +
  tm_shape(day_sp) + tm_dots(size=.2) +
  tm_legend(legend.outside=TRUE, legend.text.size=1.2)

epaplt_full

tmap_save(epaplt_full, file='/Users/student/wildfires/20181115_epa_full.png',  outer.margins = c(0,0,0,0))
```

```{r}
epaplt <- tm_shape(r_clip, bbox = pa_sp) +
  tm_raster(n=10, palette = "YlOrRd", title="") +
  tm_shape(day_sp) + tm_dots(size=.2) +
  tm_legend(legend.outside=TRUE, legend.text.size=1.2)

epaplt

tmap_save(epaplt + tm_layout(outer.margins = c(0,0,0,0)), file='/Users/student/wildfires/20181115_epa.png',  outer.margins = c(0,0,0,0))

```



Interpolate the uncorrected purpleair data
```{r}


# create empty grid
grd <- as.data.frame(spsample(pa_sp, 'regular', n=50000))
names(grd) <- c("longitude", "latitude")
coordinates(grd) <- c('longitude', 'latitude')
gridded(grd) <- TRUE
fullgrid(grd) <- TRUE

# add projection to empty grid
proj4string(pa_sp)
crs(grd) <- proj4string(pa_sp)

# interpolate!
pa_sp.idw <- gstat::idw(mean_pm25_atm ~ 1, pa_sp, newdata=grd, idp=4.0)

```


```{r}
r <- raster(pa_sp.idw)

# clip to California
r_clip <- mask(r, ca_county_map)

# map the interpolated raster
paplt <- tm_shape(r_clip) +
  tm_raster(n=10, palette = "YlOrRd", title="Interpolated PM2.5") +
  tm_shape(pa_sp) + tm_dots(size=.2) +
  tm_legend(legend.show=FALSE)

paplt

tmap_save(paplt + tm_layout(outer.margins = c(0,0,0,0)), file='/Users/student/wildfires/20181115_purpleair.png')
```

Interpolate the corrected purpleair data
```{r}


# create empty grid
grd <- as.data.frame(spsample(pa_sp, 'regular', n=50000))
names(grd) <- c("longitude", "latitude")
coordinates(grd) <- c('longitude', 'latitude')
gridded(grd) <- TRUE
fullgrid(grd) <- TRUE

# add projection to empty grid
proj4string(pa_sp)
crs(grd) <- proj4string(pa_sp)

# interpolate!
pa_sp.idw <- gstat::idw(pm25_atm_corr ~ 1, pa_sp, newdata=grd, idp=4.0)

```


```{r}
r <- raster(pa_sp.idw)

# clip to California
r_clip <- mask(r, ca_county_map)

# map the interpolated raster
papltc <- tm_shape(r_clip) +
  tm_raster(n=10, palette = "YlOrRd", title="Interpolated PM2.5") +
  tm_shape(pa_sp) + tm_dots(size=.2) +
  tm_legend(legend.show=FALSE)
  #tm_legend(legend.text.size=1.2, legend.outside=TRUE)

papltc

tmap_save(papltc + tm_layout(outer.margins = c(0,0,0,0)), file='/Users/student/wildfires/20181115_purpleair_corr.png')
```





Evaluating the interpolation

RMSE - leave one out validation
```{r}
IDW.out <- vector(length = length(pa_sp))

# create a vector of models leaving one point out
for (i in 1:length(P)) {
  IDW.out[i] <- idw(mean_pm25_atm ~ 1, pa_sp[-i,], pa_sp[i,], idp=2.0)$var1.pred
}

# plot the predicted against the observed
pred_obs_plt <- ggplot(aes(x = mean_pm25_atm, y = IDW.out), data = )
```

Map out the locations of our hourly data sensors...are we missing any areas?

Try other ways of interpolating data

# Kriging

# Polynomial







